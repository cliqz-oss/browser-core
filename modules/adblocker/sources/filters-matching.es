
export let TLDs = {"gw": "cc", "gu": "cc", "gt": "cc", "gs": "cc", "gr": "cc", "gq": "cc", "gp": "cc", "dance": "na", "tienda": "na", "gy": "cc", "gg": "cc", "gf": "cc", "ge": "cc", "gd": "cc", "gb": "cc", "ga": "cc", "edu": "na", "gn": "cc", "gm": "cc", "gl": "cc", "\u516c\u53f8": "na", "gi": "cc", "gh": "cc", "tz": "cc", "zone": "na", "tv": "cc", "tw": "cc", "tt": "cc", "immobilien": "na", "tr": "cc", "tp": "cc", "tn": "cc", "to": "cc", "tl": "cc", "bike": "na", "tj": "cc", "tk": "cc", "th": "cc", "tf": "cc", "tg": "cc", "td": "cc", "tc": "cc", "coop": "na", "\u043e\u043d\u043b\u0430\u0439\u043d": "na", "cool": "na", "ro": "cc", "vu": "cc", "democrat": "na", "guitars": "na", "qpon": "na", "\u0441\u0440\u0431": "cc", "zm": "cc", "tel": "na", "futbol": "na", "za": "cc", "\u0628\u0627\u0632\u0627\u0631": "na", "\u0440\u0444": "cc", "zw": "cc", "blue": "na", "mu": "cc", "\u0e44\u0e17\u0e22": "cc", "asia": "na", "marketing": "na", "\u6d4b\u8bd5": "na", "international": "na", "net": "na", "\u65b0\u52a0\u5761": "cc", "okinawa": "na", "\u0baa\u0bb0\u0bbf\u0b9f\u0bcd\u0b9a\u0bc8": "na", "\u05d8\u05e2\u05e1\u05d8": "na", "\uc0bc\uc131": "na", "sexy": "na", "institute": "na", "\u53f0\u7063": "cc", "pics": "na", "\u516c\u76ca": "na", "\u673a\u6784": "na", "social": "na", "domains": "na", "\u9999\u6e2f": "cc", "\u96c6\u56e2": "na", "limo": "na", "\u043c\u043e\u043d": "cc", "tools": "na", "nagoya": "na", "properties": "na", "camera": "na", "today": "na", "club": "na", "company": "na", "glass": "na", "berlin": "na", "me": "cc", "md": "cc", "mg": "cc", "mf": "cc", "ma": "cc", "mc": "cc", "tokyo": "na", "mm": "cc", "ml": "cc", "mo": "cc", "mn": "cc", "mh": "cc", "mk": "cc", "cat": "na", "reviews": "na", "mt": "cc", "mw": "cc", "mv": "cc", "mq": "cc", "mp": "cc", "ms": "cc", "mr": "cc", "cab": "na", "my": "cc", "mx": "cc", "mz": "cc", "\u0b87\u0bb2\u0b99\u0bcd\u0b95\u0bc8": "cc", "wang": "na", "estate": "na", "clothing": "na", "monash": "na", "guru": "na", "technology": "na", "travel": "na", "\u30c6\u30b9\u30c8": "na", "pink": "na", "fr": "cc", "\ud14c\uc2a4\ud2b8": "na", "farm": "na", "lighting": "na", "fi": "cc", "fj": "cc", "fk": "cc", "fm": "cc", "fo": "cc", "sz": "cc", "kaufen": "na", "sx": "cc", "ss": "cc", "sr": "cc", "sv": "cc", "su": "cc", "st": "cc", "sk": "cc", "sj": "cc", "si": "cc", "sh": "cc", "so": "cc", "sn": "cc", "sm": "cc", "sl": "cc", "sc": "cc", "sb": "cc", "rentals": "na", "sg": "cc", "se": "cc", "sd": "cc", "\u7ec4\u7ec7\u673a\u6784": "na", "shoes": "na", "\u4e2d\u570b": "cc", "industries": "na", "lb": "cc", "lc": "cc", "la": "cc", "lk": "cc", "li": "cc", "lv": "cc", "lt": "cc", "lu": "cc", "lr": "cc", "ls": "cc", "holiday": "na", "ly": "cc", "coffee": "na", "ceo": "na", "\u5728\u7ebf": "na", "ye": "cc", "\u0625\u062e\u062a\u0628\u0627\u0631": "na", "ninja": "na", "yt": "cc", "name": "na", "moda": "na", "eh": "cc", "\u0628\u06be\u0627\u0631\u062a": "cc", "ee": "cc", "house": "na", "eg": "cc", "ec": "cc", "vote": "na", "eu": "cc", "et": "cc", "es": "cc", "er": "cc", "ru": "cc", "rw": "cc", "\u0aad\u0abe\u0ab0\u0aa4": "cc", "rs": "cc", "boutique": "na", "re": "cc", "\u0633\u0648\u0631\u064a\u0629": "cc", "gov": "na", "\u043e\u0440\u0433": "na", "red": "na", "foundation": "na", "pub": "na", "vacations": "na", "org": "na", "training": "na", "recipes": "na", "\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435": "na", "\u4e2d\u6587\u7f51": "na", "support": "na", "onl": "na", "\u4e2d\u4fe1": "na", "voto": "na", "florist": "na", "\u0dbd\u0d82\u0d9a\u0dcf": "cc", "\u049b\u0430\u0437": "cc", "management": "na", "\u0645\u0635\u0631": "cc", "\u0622\u0632\u0645\u0627\u06cc\u0634\u06cc": "na", "kiwi": "na", "academy": "na", "sy": "cc", "cards": "na", "\u0938\u0902\u0917\u0920\u0928": "na", "pro": "na", "kred": "na", "sa": "cc", "mil": "na", "\u6211\u7231\u4f60": "na", "agency": "na", "\u307f\u3093\u306a": "na", "equipment": "na", "mango": "na", "luxury": "na", "villas": "na", "\u653f\u52a1": "na", "singles": "na", "systems": "na", "plumbing": "na", "\u03b4\u03bf\u03ba\u03b9\u03bc\u03ae": "na", "\u062a\u0648\u0646\u0633": "cc", "\u067e\u0627\u06a9\u0633\u062a\u0627\u0646": "cc", "gallery": "na", "kg": "cc", "ke": "cc", "\u09ac\u09be\u0982\u09b2\u09be": "cc", "ki": "cc", "kh": "cc", "kn": "cc", "km": "cc", "kr": "cc", "kp": "cc", "kw": "cc", "link": "na", "ky": "cc", "voting": "na", "cruises": "na", "\u0639\u0645\u0627\u0646": "cc", "cheap": "na", "solutions": "na", "\u6e2c\u8a66": "na", "neustar": "na", "partners": "na", "\u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe": "cc", "menu": "na", "arpa": "na", "flights": "na", "rich": "na", "do": "cc", "dm": "cc", "dj": "cc", "dk": "cc", "photography": "na", "de": "cc", "watch": "na", "dz": "cc", "supplies": "na", "report": "na", "tips": "na", "\u10d2\u10d4": "cc", "bar": "na", "qa": "cc", "shiksha": "na", "\u0443\u043a\u0440": "cc", "vision": "na", "wiki": "na", "\u0642\u0637\u0631": "cc", "\ud55c\uad6d": "cc", "computer": "na", "best": "na", "voyage": "na", "expert": "na", "diamonds": "na", "email": "na", "wf": "cc", "jobs": "na", "bargains": "na", "\u79fb\u52a8": "na", "jp": "cc", "jm": "cc", "jo": "cc", "ws": "cc", "je": "cc", "kitchen": "na", "\u0a2d\u0a3e\u0a30\u0a24": "cc", "\u0627\u06cc\u0631\u0627\u0646": "cc", "ua": "cc", "buzz": "na", "com": "na", "uno": "na", "ck": "cc", "ci": "cc", "ch": "cc", "co": "cc", "cn": "cc", "cm": "cc", "cl": "cc", "cc": "cc", "ca": "cc", "cg": "cc", "cf": "cc", "community": "na", "cd": "cc", "cz": "cc", "cy": "cc", "cx": "cc", "cr": "cc", "cw": "cc", "cv": "cc", "cu": "cc", "pr": "cc", "ps": "cc", "pw": "cc", "pt": "cc", "holdings": "na", "wien": "na", "py": "cc", "ai": "cc", "pa": "cc", "pf": "cc", "pg": "cc", "pe": "cc", "pk": "cc", "ph": "cc", "pn": "cc", "pl": "cc", "pm": "cc", "\u53f0\u6e7e": "cc", "aero": "na", "catering": "na", "photos": "na", "\u092a\u0930\u0940\u0915\u094d\u0937\u093e": "na", "graphics": "na", "\u0641\u0644\u0633\u0637\u064a\u0646": "cc", "\u09ad\u09be\u09b0\u09a4": "cc", "ventures": "na", "va": "cc", "vc": "cc", "ve": "cc", "vg": "cc", "iq": "cc", "vi": "cc", "is": "cc", "ir": "cc", "it": "cc", "vn": "cc", "im": "cc", "il": "cc", "io": "cc", "in": "cc", "ie": "cc", "id": "cc", "tattoo": "na", "education": "na", "parts": "na", "events": "na", "\u0c2d\u0c3e\u0c30\u0c24\u0c4d": "cc", "cleaning": "na", "kim": "na", "contractors": "na", "mobi": "na", "center": "na", "photo": "na", "nf": "cc", "\u0645\u0644\u064a\u0633\u064a\u0627": "cc", "wed": "na", "supply": "na", "\u7f51\u7edc": "na", "\u0441\u0430\u0439\u0442": "na", "careers": "na", "build": "na", "\u0627\u0644\u0627\u0631\u062f\u0646": "cc", "bid": "na", "biz": "na", "\u0627\u0644\u0633\u0639\u0648\u062f\u064a\u0629": "cc", "gift": "na", "\u0434\u0435\u0442\u0438": "na", "works": "na", "\u6e38\u620f": "na", "tm": "cc", "exposed": "na", "productions": "na", "koeln": "na", "dating": "na", "christmas": "na", "bd": "cc", "be": "cc", "bf": "cc", "bg": "cc", "ba": "cc", "bb": "cc", "bl": "cc", "bm": "cc", "bn": "cc", "bo": "cc", "bh": "cc", "bi": "cc", "bj": "cc", "bt": "cc", "bv": "cc", "bw": "cc", "bq": "cc", "br": "cc", "bs": "cc", "post": "na", "by": "cc", "bz": "cc", "om": "cc", "ruhr": "na", "\u0627\u0645\u0627\u0631\u0627\u062a": "cc", "repair": "na", "xyz": "na", "\u0634\u0628\u0643\u0629": "na", "viajes": "na", "museum": "na", "fish": "na", "\u0627\u0644\u062c\u0632\u0627\u0626\u0631": "cc", "hr": "cc", "ht": "cc", "hu": "cc", "hk": "cc", "construction": "na", "hn": "cc", "solar": "na", "hm": "cc", "info": "na", "\u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd": "cc", "uy": "cc", "uz": "cc", "us": "cc", "um": "cc", "uk": "cc", "ug": "cc", "builders": "na", "ac": "cc", "camp": "na", "ae": "cc", "ad": "cc", "ag": "cc", "af": "cc", "int": "na", "am": "cc", "al": "cc", "ao": "cc", "an": "cc", "aq": "cc", "as": "cc", "ar": "cc", "au": "cc", "at": "cc", "aw": "cc", "ax": "cc", "az": "cc", "ni": "cc", "codes": "na", "nl": "cc", "no": "cc", "na": "cc", "nc": "cc", "ne": "cc", "actor": "na", "ng": "cc", "\u092d\u093e\u0930\u0924": "cc", "nz": "cc", "\u0633\u0648\u062f\u0627\u0646": "cc", "np": "cc", "nr": "cc", "nu": "cc", "xxx": "na", "\u4e16\u754c": "na", "kz": "cc", "enterprises": "na", "land": "na", "\u0627\u0644\u0645\u063a\u0631\u0628": "cc", "\u4e2d\u56fd": "cc", "directory": "na"};

// Some content policy types used in filters
const CPT = {
  TYPE_OTHER: 1,
  TYPE_SCRIPT: 2,
  TYPE_IMAGE: 3,
  TYPE_STYLESHEET: 4,
  TYPE_OBJECT: 5,
  TYPE_SUBDOCUMENT: 7,
  TYPE_PING: 10,
  TYPE_XMLHTTPREQUEST: 11,
  TYPE_OBJECT_SUBREQUEST: 12,
  TYPE_MEDIA: 15,
  TYPE_WEBSOCKET: 16,
};


function checkContentPolicy(filter, cpt) {
  // Check content policy type only if at least one content policy has
  // been specified in the options.
  if (!filter.fromAny) {
    const options = [
      [filter.fromSubdocument, CPT.TYPE_SUBDOCUMENT],
      [filter.fromImage, CPT.TYPE_IMAGE],
      [filter.fromMedia, CPT.TYPE_MEDIA],
      [filter.fromObject, CPT.TYPE_OBJECT],
      [filter.fromObjectSubrequest, CPT.TYPE_OBJECT_SUBREQUEST],
      [filter.fromOther, CPT.TYPE_OTHER],
      [filter.fromPing, CPT.TYPE_PING],
      [filter.fromScript, CPT.TYPE_SCRIPT],
      [filter.fromStylesheet, CPT.TYPE_STYLESHEET],
      [filter.fromWebsocket, CPT.TYPE_WEBSOCKET],
      [filter.fromXmlHttpRequest, CPT.TYPE_XMLHTTPREQUEST],
    ];

    // If content policy type `option` is specified in filter filter,
    // then the policy type of the request must match.
    // - If more than one policy type is valid, we must find at least one
    // - If we found a blacklisted policy type we can return `false`
    let foundValidCP = null;
    for (let i = 0; i < options.length; i++) {
      const [option, policyType] = options[i];

      // Found a fromX matching the origin policy of the request
      if (option === true) {
        if (cpt === policyType) {
          foundValidCP = true;
          break;
        } else {
          foundValidCP = false;
        }
      }

      // This rule can't be used with filter policy type
      if (option === false && cpt === policyType) {
        return false;
      }
    }

    // Couldn't find any policy origin matching the request
    if (foundValidCP === false) {
      return false;
    }
  }

  return true;
}


function checkOptions(filter, request) {
  // Source
  const sHost = request.sourceHostname;
  const sHostGD = request.sourceGD;

  // Url endpoint
  const hostGD = request.hostGD;

  // Check option $third-party
  // source domain and requested domain must be different
  if ((filter.firstParty === false || filter.thirdParty === true) && sHostGD === hostGD) {
    return false;
  }

  // $~third-party
  // source domain and requested domain must be the same
  if ((filter.firstParty === true || filter.thirdParty === false) && sHostGD !== hostGD) {
    return false;
  }

  // URL must be among these domains to match
  if (filter.optDomains !== null &&
     !(filter.optDomains.has(sHostGD) ||
       filter.optDomains.has(sHost))) {
    return false;
  }

  // URL must not be among these domains to match
  if (filter.optNotDomains !== null &&
      (filter.optNotDomains.has(sHostGD) ||
       filter.optNotDomains.has(sHost))) {
    return false;
  }

  if (!checkContentPolicy(filter, request.cpt)) {
    return false;
  }

  return true;
}


function checkPattern(filter, request) {
  const url = request.url;
  const host = request.hostname;

  // Try to match url with pattern
  if (filter.isHostnameAnchor) {
    const matchIndex = host.indexOf(filter.hostname);
    // Either start at beginning of hostname or be preceded by a '.'
    if ((matchIndex > 0 && host[matchIndex - 1] === '.') || matchIndex === 0) {
      // Extract only the part after the hostname
      const urlPattern = url.substring(url.indexOf(filter.hostname) + filter.hostname.length);
      if (filter.isRegex) {
        // If it's a regex, it should match the pattern after hostname
        return filter.regex.test(urlPattern);
      } else if (filter.isRightAnchor) {
        // If it's a right anchor, then the filterStr should match exactly
        return urlPattern === filter.filterStr;
      } else {
        return urlPattern.startsWith(filter.filterStr);
      }
    }
  } else {
    if (filter.isRegex) {
      return filter.regex.test(url);
    } else if (filter.isLeftAnchor && filter.isRightAnchor) {
      return url === filter.filterStr;
    } else if (filter.isLeftAnchor) {
      return url.startsWith(filter.filterStr);
    } else if (filter.isRightAnchor) {
      return url.endsWith(filter.filterStr);
    }

    return url.includes(filter.filterStr);
  }

  return false;
}


export function matchNetworkFilter(filter, request) {
  if (filter.supported) {
    if (!checkOptions(filter, request)) {
      return false;
    }

    return checkPattern(filter, request);
  }

  return false;
}


/* Checks that hostnamePattern matches at the end of the hostname.
 * Partial matches are allowed, but hostname should be a valid
 * subdomain of hostnamePattern.
 */
function checkHostnamesPartialMatch(hostname, hostnamePattern) {
  if (hostname.endsWith(hostnamePattern)) {
    const patternIndex = hostname.indexOf(hostnamePattern);
    if (patternIndex === 0 || (patternIndex !== -1 && hostname.charAt(patternIndex - 1) === '.')) {
      return true;
    }
  }

  return false;
}


/* Checks if `hostname` matches `hostnamePattern`, which can appear as
 * a domain selector in a cosmetic filter: hostnamePattern##selector
 *
 * It takes care of the concept of entities introduced by uBlock: google.*
 * https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#entity-based-cosmetic-filters
 */
function matchHostname(hostname, hostnamePattern) {
  const globIndex = hostnamePattern.indexOf('.*');
  if (globIndex === (hostnamePattern.length - 2)) {
    // Match entity:
    const entity = hostnamePattern.substring(0, globIndex);

    // Ignore TLDs suffix
    const parts = hostname.split('.').reverse();
    let i = 0;
    while (i < parts.length && TLDs[parts[i]]) {
      i += 1;
    }

    // Check if we have a match
    if (i < parts.length) {
      return checkHostnamesPartialMatch(parts.splice(i).reverse().join('.'), entity);
    }

    return false;
  }

  return checkHostnamesPartialMatch(hostname, hostnamePattern);
}


function matchHostnames(hostname, hostnames) {
  // TODO: Do we want to return `true` when there is no hostname constraint?
  if (!hostnames) {
    return false;
  }

  for (const hn of hostnames) {
    if (matchHostname(hostname, hn)) {
      return true;
    }
  }

  return false;
}


export function matchCosmeticFilter(filter, hostname) {
  if (filter.supported) {
    if (filter.hostnames && hostname) {
      return matchHostnames(hostname, filter.hostnames);
    }

    return true;
  }

  return false;
}
